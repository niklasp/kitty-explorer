<<<<<<< Updated upstream
=======
import cache from "memory-cache";
// import jsonData from './latest-kitties.json';
import { gql, useQuery } from '@apollo/client';
import client from "../apollo-client";

>>>>>>> Stashed changes
import { orderBy } from "lodash";
// import jsonData from './kitties.json';

<<<<<<< Updated upstream
export async function getKitties() {
  const response = await fetch("http://138.68.123.124/get_nfts_by_collection/800f8a914281765a7d-KITTY" );
  const jsonData = await response.json();

  // transform the data we get from the json to a format we want
  const realKittyData = jsonData.map( ( kitObj ) => {
=======
// const NFT_BY_ID_ENDPOINT = 'http://138.68.123.124/get_nft_by_id/';

export async function getKitties( orderby = 'id', order='desc' ) {
  // const response = await fetch("http://138.68.123.124/get_nfts_by_collection/800f8a914281765a7d-KITTY" );
  // const data = await response.json();

  const { data } = await client.query({
    query: gql`
      query {
        nftEntities(
          where: {
            collection: {
              id_eq: "800f8a914281765a7d-KITTY"
            }
          })
        {
          id
          sn
          name
          price
          meta {
            animationUrl
            image
            description
          }
          emotes {
            value
          }
        }
      }
    `,
  })

  let allKitties = [];
  let forSaleCount = 0;
  let floorKitties = {
    kitties:[],
    price: Number.MAX_SAFE_INTEGER,
  };

  console.log( data );

  const realKittyData = data.nftEntities.map( ( kitObj ) => {
>>>>>>> Stashed changes
    const {
      sn,
      meta,
      price,
      id
    } = kitObj;

<<<<<<< Updated upstream
    let parsedMeta = {};

    // parse the metadata: string -> json
    try {
      metadata.slice(1, -1);
      parsedMeta = JSON.parse( metadata );
    } catch( e ) {
      console.log( 'error parsing metadata for ', kitObj.id );
    }
=======
>>>>>>> Stashed changes

    // use some ipfs gateways to transform the media uri to a URL to the image
    // (nextjs will cache those requests so you should be safe from timeouts)
    let mediaUri = '';
    if ( Object.keys( meta ).length > 0 ) {
      if ( ! meta.thumbnailUri ) {
        mediaUri = meta.image.replace("ipfs://", "https://gateway.ipfs.io/");
      } else {
        mediaUri = meta.thumbnailUri.replace("ipfs://", "https://gateway.ipfs.io/");
      }
    }

    const kittyId = sn.slice(-3);

<<<<<<< Updated upstream
=======
    if ( price !== '0' ) {
      forSaleCount++;

      if ( parseInt(price) < floorKitties.price ) {
        floorKitties.kitties = [ { ...kitObj, sn: kitObj.sn, id:kittyId } ];
        floorKitties.price = parseInt(price);
      } else if ( parseInt(price) === floorKitties.price ) {
        floorKitties.kitties.push( { ...kitObj, sn: kitObj.sn, id:kittyId } );
      }
    }

>>>>>>> Stashed changes
    return {
      uuid: id,
      id: kittyId,
      forsale: price,
      image: mediaUri,
      meta,
    }
  });

  // sort the data by id desc
  const sortedData = orderBy( realKittyData, item => item[ 'id' ], [ 'desc' ]);

  return {
    kitties: sortedData,
  };
}
<<<<<<< Updated upstream
=======

export function getKittiesSorted( allKitties, orderby = 'id', order='desc' ) {
  let sortedData;

  console.log( 'before sort', allKitties[0].id, orderby, order)

  if ( orderby === 'forsale' ) {
    sortedData = orderBy( allKitties, item => {
      let a = parseInt( item.forsale );
      if ( a === 0 ) {
        a = order === 'desc' ? -1 : Number.MAX_SAFE_INTEGER;
      }
      return a;
    }, order )
  } else {
    sortedData = orderBy( allKitties, item => item[ orderby ], [ order ]);
  }

  console.log( 'aftersort', sortedData[0].id )
  return sortedData;
}

export async function getKittyDetail( uuid ) {
  const cachedResponse = cache.get( uuid );
  if (cachedResponse) {
    return cachedResponse;
  } else {
    const hours = 24;
    const response = await fetch(`${ NFT_BY_ID_ENDPOINT }${ uuid }` );
    const data = await response.json();
    cache.put(uuid, data, hours * 1000 * 60 * 60);

    const {
      id,
      metadata,
      ...rest
    } = data;

    const kittyId = id.slice(-3);

    try {
      const parsedMeta = JSON.parse( metadata );
      const mediaUri = parsedMeta.mediaUri.replace("ipfs://", "https://gateway.ipfs.io/");

      return {
        uuid: id,
        id: kittyId,
        mediaUri,
        description,
        forsale,
        ...parsedMeta,
        ...rest
      }
    } catch( e ) {
      return {
        uuid: id,
        id: kittyId,
        ...rest
      }
    }
  }
}
>>>>>>> Stashed changes
